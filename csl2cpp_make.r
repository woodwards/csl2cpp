# make cpp based on parsed csl

vrep <- function(what, times){ # vectorised string rep
  sapply(times, function(x) paste(rep(what, x), collapse=""))
}

put_lines <- function(cpp, indent, lines){
  # insert rows
	first_row <- attr(cpp, "row") + 1
	last_row <- first_row+length(lines)-1
	tab <- vrep("\t", indent)
	cpp[first_row:last_row] <- paste(tab, lines, "\n", sep="") # multiple lines
	attr(cpp, "row") <- last_row
	return(cpp)
}

smoosh <- function(...){
  # like paste but remove excess spaces
  str_c(..., sep=" ") %>%
    str_squish( )
}

make_cpp <- function(csl, tokens, model_name, delay_post=FALSE){

  cat("delay post processing :", delay_post, "\n")
  class_name <- paste(model_name, "_class", sep="")
  has_derivt <- any(csl$line_type == "derivt")

	# state variables
  integ <- csl$integ[csl$line_type == "integ"]
  state <- str_match(integ, "^[:alpha:]+[[:alnum:]_]*")[,1]
	rate <- str_trim(str_replace(integ, "^[:alpha:]+[[:alnum:]_]*", "")) # rate expressions
	n_state <- length(state)
	# derivt variables
	derivt <- csl$integ[csl$line_type == "derivt"]
	slope <- str_match(derivt, "^[:alpha:]+[[:alnum:]_]*")[,1]
	slopeof <- str_trim(str_replace(derivt, "^[:alpha:]+[[:alnum:]_]*", ""))
	slopeof <- str_replace_all(slopeof, "= ", "")
	# pullable and pushable variables
	pullable <- tokens$name[tokens$decl_type %in% c("double", "int", "bool", "auto")]
	n_pullable <- length(pullable)
	pushable <- tokens$name[tokens$decl_type %in% c("double", "int", "bool", "auto") & tokens$decl_static==FALSE]
  n_pushable <- length(pushable)
  cat("n state :", n_state, "\n")
  cat("n pullable :", n_pullable, "\n")
  cat("n pushable :", n_pushable, "\n")

	# uninitialised variables after sort
	assumed_all <- tokens$name[tokens$set_status=="assumed"]

	# browser( )

	# create an empty vector of strings
	cpp <- vector("character", nrow(csl) * 2 + 200) # estimate output length
	attr(cpp, "row") <- 0 # create an attribute for the row counter

	# module header
	lines <- c(
	       "// *****************************************************",
			   "// this file is automatically generated from an R script",
			   "// *****************************************************",
			   "#include <unordered_map>",
			   "#include <map>",
			   "#include <string>",
			   "#include <cmath>",
			   "#define BOOST_CONFIG_SUPPRESS_OUTDATED_MESSAGE",
			   "#include <boost/numeric/odeint.hpp>",
			   # "#include <boost/array.hpp>", # try std::array instead as recommended by boost
			   "#include <array>",
			   "",
			   "using namespace std; // needed for math functions",
			   "")
	cpp <- put_lines(cpp, 0, lines)

	#### model header comments ####
	rows <- csl$section == "header"
	lines <- csl$tail[rows]
	cpp <- put_lines(cpp, 0, lines)
	cat("header comments :", sum(rows), "\n")

	# class declaration
	lines <- c("",
             paste("class", class_name, "{"),
             "",
             "private:",
             "")
	cpp <- put_lines(cpp, 0, lines)

	# class properties
	lines <- c("// switches",
	           "bool print_debug_messages = false;",
	           "",
	           "// specify number of variables",
             paste("static constexpr int n_state_variables =", n_state, ";"),
             paste("static constexpr int n_pullable_variables =", n_pullable, ";"),
	           "",
              "// declare state_type and t",
	           paste("typedef std::array< double , n_state_variables > state_type;"),
	           "double t;",
	           ifelse(has_derivt, "double t_previous;", ""),
	           "",
	           "// declare event list",
	           "std::multimap< double , std::string > event_list;",
	           "",
	           "// add event",
	           "void schedule( double event_time, std::string event_name ){",
	           "",
	           "\tevent_list.insert( std::make_pair( event_time , event_name ) );",
	           "",
	           "}",
	           "",
	           "// declare boost::odeint stepper",
             "typedef boost::numeric::odeint::runge_kutta4< state_type > stepper_type;",
             "stepper_type stepper;",
	           "")
	cpp <- put_lines(cpp, 1, lines)

  #### declare model variables ####
	cpp <- put_lines(cpp, 1, "// declare model variables")
	rows <- csl$decl > ""
	lines <- smoosh(csl$static[rows], csl$type[rows], csl$decl[rows], csl$dend[rows])
	cpp <- put_lines(cpp, 1, lines)
	cat("declaration lines :", sum(rows), "\n")
	# declare numerical derivatives
	if (has_derivt){
	  lines <- smoosh("double", paste(slopeof, "_previous", sep=""), ";")
	  cpp <- put_lines(cpp, 1, lines)
	}

  # get state
  cpp <- put_lines(cpp, 1, c("", "state_type get_state ( ) {"))
  cpp <- put_lines(cpp, 2, c("", "state_type current_state;", "", "// return current state"))
  lines <- paste("current_state[", 0:(n_state-1), "] = ", state, ";", sep="")
  cpp <- put_lines(cpp, 2, lines)
  cpp <- put_lines(cpp, 2, c("", "return( current_state );"))
  cpp <- put_lines(cpp, 1, c("", "} // end get_state", ""))

  # set state
  cpp <- put_lines(cpp, 1, c("void set_state ( state_type this_state ) {"))
  cpp <- put_lines(cpp, 2, c("", "// set state"))
  lines <- paste(state, " = this_state[", 0:(n_state-1), "];", sep="")
  cpp <- put_lines(cpp, 2, lines)
  cpp <- put_lines(cpp, 1, c("", "} // end set_state"))

	# constructor head
	cpp <- put_lines(cpp, 0, c("", "public:", ""))
	lines <- c("// unordered_map gives user efficient access to variables by name",
	           "std::unordered_map< std::string , double > variable;", "")
	cpp <- put_lines(cpp, 1, lines)
	# array initialisation list (class constructor list)
	rows <- csl$ccl > ""
	if (any(rows)){
	  lines <- c("// constructor",
	             paste(class_name, "( ) :"), "")
	  cpp <- put_lines(cpp, 1, lines)
	  cpp <- put_lines(cpp, 2, c("// array initialisation list",
  	                           "// warning: these are executed in the order of the member declarations"))
  	csl$dend[max(which(rows))] <- "" # remove last comma
  	lines <- smoosh(csl$ccl[rows], csl$dend[rows], csl$tail[rows])
  	indent <- if_else(str_detect(lines, "^\\{"), 3, 2) # indent array initialisation lines
  	cpp <- put_lines(cpp, indent, lines)
	} else {
	  lines <- c("// constructor",
	             paste(class_name, "( )"), "")
	  cpp <- put_lines(cpp, 1, lines)
	}

	# constructor body
	lines <- c("",
	           "// constructor body",
	           "{",
	           "",
	           "\t// reserve buckets to minimise storage and avoid rehashing",
	           "\tvariable.reserve( n_pullable_variables );",
	           "",
	           "} // end constructor",
	           "")
	cpp <- put_lines(cpp, 1, lines)

	#### initialise model ####
	cpp <- put_lines(cpp, 1, c("void initialise_model ( double start_time = 0.0 , bool set_debug_status = false ) {"))
	cpp <- put_lines(cpp, 2, c("",
	                           "// initialise t",
	                           "t = start_time;",
	                           ifelse(has_derivt, "t_previous = t;", ""),
	                           "",
	                           "// set debug status",
	                           "print_debug_messages = set_debug_status;",
	                           ""))
	# uninitialised variables
	if (length(assumed_all)>0){
  	cpp <- put_lines(cpp, 2, c("", "// initialise illegally used variables as per acslx"))
  	lines <- paste(assumed_all, "= 5.5555e33;")
  	cpp <- put_lines(cpp, 2, lines)
	}
	# model initialisation
	rows <- csl$section == "initial"
  if (any(rows)){
  	cpp <- put_lines(cpp, 2, c("", "// initial calculations"))
  	lines <- if_else(csl$init[rows] > "",
  	                 smoosh(csl$init[rows], csl$delim[rows], csl$tail[rows]),
  	                 csl$tail[rows])
  	indent <- ifelse(csl$label[rows]>"", 1, 2) + pmax(0, csl$indent[rows] - min(csl$indent[rows]))
  	cpp <- put_lines(cpp, indent, lines)
  	cat("initial calculations lines :", sum(rows), "\n")
  }
	# state variable initial conditions
	rows <- csl$line_type == "integ"
	cpp <- put_lines(cpp, 2, c("", "// initialise state variables"))
	lines <- smoosh(csl$init[rows], csl$delim[rows])
	indent <- ifelse(csl$label[rows]>"", 1, 2) + pmax(0, csl$indent[rows] - min(csl$indent[rows]))
	cpp <- put_lines(cpp, indent, lines)
	# numerical derivatives initial conditions
	if (has_derivt){
	  rows <- csl$line_type == "derivt"
	  cpp <- put_lines(cpp, 2, c("", "// initialise numerical derivatives"))
  	lines <- smoosh(csl$init[rows], csl$delim[rows])
  	cpp <- put_lines(cpp, 2, lines)
  	lines <- smoosh(paste(slopeof, "_previous", sep=""), "=", slopeof, ";")
  	cpp <- put_lines(cpp, 2, lines)
	}
	# initial rate calculations
	lines <- c("",
	           "// initial calculation of rates, for use in events",
	           "calculate_rate( );",
	           "")
	cpp <- put_lines(cpp, 2, lines)
	# close off
	cpp <- put_lines(cpp, 1, c("} // end initialise_model", ""))

	# pull variables from model (and constants)
	# FIXME would be faster if we pull variables variables separately from constants
	cpp <- put_lines(cpp, 1, "void pull_variables_from_model ( ) {")
	cpp <- put_lines(cpp, 2, c("",
	                           "// pull system time",
	                           "variable[\"t\"] = t;",
	                           "",
	                           "// pull model variables"))
	lines <- paste("variable[\"", pullable, "\"] = ", pullable, ";", sep="") # implicit type conversion
	cpp <- put_lines(cpp, 2, lines)
	cpp <- put_lines(cpp, 1, c("", "} // end pull_variables_from_model", ""))

	# push variables to model
	cpp <- put_lines(cpp, 1, "void push_variables_to_model ( ) {")
	cpp <- put_lines(cpp, 2, c("",
	                           "// push system time",
	                           "t = variable[\"t\"];",
	                           "",
	                           "// push model variables"))
	lines <- paste(pushable, " = variable[\"", pushable, "\"];", sep="") # implicit type conversion
	cpp <- put_lines(cpp, 2, lines)
	cpp <- put_lines(cpp, 1, c("", "} // end push_variables_to_model", ""))

	#### do next event ####
	cpp <- put_lines(cpp, 1, c("void do_event ( string next_event ) {", ""))
	rows <- csl$section == "discrete"
	if (any(rows)){
	  cpp <- put_lines(cpp, 2, c("// find event"))
	  lines <- if_else(csl$disc[rows] > "",
  	                 smoosh(csl$disc[rows], csl$delim[rows], csl$tail[rows]),
  	                 csl$tail[rows])
	  indent <- ifelse(csl$label[rows]>"", 1, 2) + pmax(0, csl$indent[rows] - min(csl$indent[rows]))
	  cpp <- put_lines(cpp, indent, lines)
	}
	cat("event lines :", sum(rows), "\n")
	cpp <- put_lines(cpp, 1, c("", "} // end do_event", ""))

	#### do all current events ####
	cpp <- put_lines(cpp, 1, c("double do_current_events ( double max_next_time ) {", ""))
	lines <- c("static constexpr double eps = 0.00001;",
	           "double next_time = max_next_time;",
	           "",
	           "if (print_debug_messages) {",
	           "\tstd::cout << \"event check at\" << \'\\t\' << t << std::endl;",
	           "}",
	           "",
	           "do {",
	           "\tif ( event_list.begin( ) == event_list.end( ) ){",
	           "\t\t// no events",
	           "\t\tnext_time = max_next_time + 1;",
	           "\t} else if ( event_list.begin( )->first < t - eps ) {",
	           "\t\t// missed event (handle bugs)",
	           "\t\tevent_list.erase( event_list.begin( ) );",
	           "\t\tnext_time = t - 1;",
	           "\t} else if ( event_list.begin( )->first < t + eps ) {",
	           "\t\tif (print_debug_messages) {",
	           "\t\t\tstd::cout << \"event at\" << \'\\t\' << t << std::endl;",
	           "\t\t}",
	           "\t\tdo_event( event_list.begin( )->second );",
	           "\t\tevent_list.erase( event_list.begin( ) );",
	           "\t\tnext_time = t - 1;",
	           "\t} else {",
	           "\t\t// next event",
	           "\t\tnext_time = event_list.begin( )->first;",
	           "\t}",
	           "} while ( next_time < t + eps );",
	           "",
	           "next_time = std::min( max_next_time, next_time );",
	           "",
	           "if (print_debug_messages) {",
	           "\tstd::cout << \"next event at\" << \'\\t\' << next_time << std::endl;",
	           "}",
	           "",
	           "return( next_time );",
	           "")
	cpp <- put_lines(cpp, 2, lines)
	cpp <- put_lines(cpp, 1, c("} // end do_current_events", ""))

	#### calculate rate ####
	cpp <- put_lines(cpp, 1, "void calculate_rate ( ) {")
	# rate calculation from derivative section
	cpp <- put_lines(cpp, 2, c("",
	                           "// derivative calculations",
	                           ""))
	rows <- which(csl$section == "derivative" & (csl$dep == "for_rate" | delay_post==FALSE))
	lines <- if_else(csl$calc[rows] > "",
	                 smoosh(csl$calc[rows], csl$delim[rows], csl$tail[rows]),
	                 csl$tail[rows])
	indent <- ifelse(csl$label[rows]>"", 1, 2) + pmax(0, csl$indent[rows] - min(csl$indent[rows]))
	cpp <- put_lines(cpp, indent, lines)
	cat("calculate rate lines :", length(rows), "\n")
	cpp <- put_lines(cpp, 1, c("", "} // end calculate_rate", ""))

	#### post processing ####
	cpp <- put_lines(cpp, 1, "void post_processing ( ) {")
	# post processing from derivative section
	cpp <- put_lines(cpp, 2, c("", "// post processing calculations from derivative"))
	rows <- which(csl$section == "derivative" & (csl$dep == "" & delay_post==TRUE))
	lines <- if_else(csl$calc[rows] > "",
	                 smoosh(csl$calc[rows], csl$delim[rows], csl$tail[rows]),
	                 csl$tail[rows])
	indent <- ifelse(csl$label[rows]>"", 1, 2) + pmax(0, csl$indent[rows] - min(csl$indent[rows]))
	cpp <- put_lines(cpp, indent, lines)
	cat("post processing 1 lines :", length(rows), "\n")
	# and also dynamic section
	cpp <- put_lines(cpp, 2, c("", "// post processing calculations from dynamic"))
	rows <- which(csl$section == "dynamic")
	lines <- if_else(csl$calc[rows] > "",
	                 smoosh(csl$calc[rows], csl$delim[rows], csl$tail[rows]),
	                 csl$tail[rows])
	indent <- ifelse(csl$label[rows]>"", 1, 2) + pmax(0, csl$indent[rows] - min(csl$indent[rows]))
	cpp <- put_lines(cpp, indent, lines)
	cat("post processing 2 lines :", length(rows), "\n")
	cpp <- put_lines(cpp, 1, c("", "} // end post_processing", ""))

	#### rate operator ####
	cpp <- put_lines(cpp, 1, c("// rate operator called by boost::odeint::integrate( )",
	                           "void operator( )( const state_type &odeint_state , state_type &odeint_rate, double odeint_time ){",
	                           ""))
	cpp <- put_lines(cpp, 2, c("",
	                           "// calculate rate",
	                           "set_state( odeint_state );",
	                           "t = odeint_time;",
	                           "calculate_rate( );",
	                           "",
	                           "// return rate"))
	lines <- paste("odeint_rate[", 0:(n_state-1), "] ", rate, ";", sep="")
	cpp <- put_lines(cpp, 2, lines)
	cpp <- put_lines(cpp, 1, c("", "} // end rate operator", ""))

	#### observer operator ####
	lines <- c("// observer operator called by boost::odeint::integrate( )",
	           "// https://stackoverflow.com/questions/12150160/odeint-streaming-observer-and-related-questions",
	           "void operator( )( const state_type &odeint_state , double odeint_time ){",
	           "")
	cpp <- put_lines(cpp, 1, lines)
	if (has_derivt){
	  lines <- c("if (print_debug_messages) {",
	             "\tstd::cout << \"observer at\" << \'\\t\' << odeint_time << \'\\t\' << t_previous << std::endl;",
	             "}",
	             "",
	             "// calculate rates",
	             "set_state( odeint_state );",
	             "t = odeint_time;",
	             "calculate_rate( );",
	             "",
	             "// recalculate numerical derivatives after step",
	             "if ( t > t_previous ) {"
	             )
	  cpp <- put_lines(cpp, 2, lines)
	  lines <- smoosh(slope, "= (", slopeof, "-", paste(slopeof, "_previous", sep=""), ") / ( t - t_previous ) ;")
	  cpp <- put_lines(cpp, 3, lines)
	  cpp <- put_lines(cpp, 2, "}")
  	lines <- smoosh(paste(slopeof, "_previous", sep=""), "=", slopeof, ";")
  	cpp <- put_lines(cpp, 2, lines)
  	lines <- c("t_previous = odeint_time;", "")
  	cpp <- put_lines(cpp, 2, lines)
	}
	cpp <- put_lines(cpp, 1, c("} // end observer operator ", ""))

	#### take a step ####
	cpp <- put_lines(cpp, 1, c("int step_to_next_time ( double next_time , double time_step ) {", ""))
	cpp <- put_lines(cpp, 2, c("state_type odeint_state;",
	                           "double odeint_time;",
	                           "int nsteps;", ""))
	lines <- c("if (print_debug_messages) {",
	           "\tstd::cout << \"start integ at\" << \'\\t\' << t << std::endl;",
	           "}",
	           "",
	           "odeint_state = get_state( );",
	           "odeint_time = t;",
	           "// https://stackoverflow.com/questions/10976078/using-boostnumericodeint-inside-the-class",
	           "nsteps = boost::numeric::odeint::integrate_const( stepper , std::ref(*this) , odeint_state, odeint_time , next_time , time_step , std::ref(*this) );",
	           "set_state( odeint_state );",
	           "t = next_time;", "",
	           "return( nsteps );", "")
	cpp <- put_lines(cpp, 2, lines)
	cpp <- put_lines(cpp, 1, c("} // end step_to_next_time", ""))

	#### advance model method ####
	lines <- c("int advance_model ( double advance_time , double time_step ) {", "")
	cpp <- put_lines(cpp, 1, lines)
	lines <- c(
	  "double next_time;",
	  "int nsteps = 0;",
	  "",
	  "do {",
	  "",
	  "\t// do current events",
	  "\tnext_time = do_current_events( advance_time );",
	  "",
	  "\t// advance model to next event or advance_time",
	  "\tnsteps += step_to_next_time( next_time , time_step );",
	  "",
	  "} while ( t < advance_time );",
	  "",
	  "post_processing( );",
	  "",
	  "return( nsteps );"
	  )
	cpp <- put_lines(cpp, 2, lines)
	cpp <- put_lines(cpp, 1, c("", "} // end advance_model"))
	cpp <- put_lines(cpp, 0, c("", paste("}; // end ", class_name, sep=""), ""))

	#### mfiles ####
	mfilesi <- which(csl$line_type=="mfile")
	while (length(mfilesi)>0){
	  # next mfile
	  starti <- mfilesi[[1]]
	  endi <- csl$stack[starti]
	  lines <- c("",
	             smoosh(csl$mfile[starti], csl$delim[starti]),
	             "")
	  cpp <- put_lines(cpp, 0, lines)
	  rows <- seq(starti+1, endi-1)
	  lines <- smoosh(csl$mfile[rows], csl$delim[rows], csl$tail[rows])
	  cpp <- put_lines(cpp, 1, lines)
	  lines <- c("",
	             smoosh(csl$mfile[endi], csl$delim[endi])
	             )
	  cpp <- put_lines(cpp, 0, lines)
    # any more mfiles?
	  mfilesi <- tail(mfilesi, -1)
	}

	cat("total lines :", length(cpp), "\n")

	return(cpp)

}

